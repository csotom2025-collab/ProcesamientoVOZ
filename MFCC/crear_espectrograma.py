# Converted from crear_espectrograma.ipynb
# This script was generated by extracting code cells from the original Jupyter notebook.

import os
import numpy as np
import scipy
from scipy.io import wavfile
import scipy.fftpack as fft
from scipy.signal import get_window
import IPython.display as Audio
import matplotlib.pyplot as plt
import librosa
print(np.__version__)

# CARGANDO EL AUDIO

sample_rate, signal = scipy.io.wavfile.read('C:/Users/usuario/Desktop/ProcesamientoVOZ/MFCC/cero_1.wav')  # File assumed to be in the same directory

#signal, sample_rate = librosa.load('cero1.wav', sr=11025)  # sr is the sample rate, default is 22050 Hz
audio=signal

#signal=np.array(signal[1,])
print (signal.shape[0])
#signal = signal[0:int(3.5 * sample_rate)]  # Keep the first 3.5 seconds

print("Sample rate: {0}Hz".format(sample_rate))
print("Audio duration: {0}s".format(len(signal) / sample_rate))

t= np.arange (0, int(signal.shape[0])/sample_rate, 1/sample_rate)

#Audio (y, rate=sr)

plt.figure(figsize=(15,4))
plt.plot(np.linspace(0, len(audio) / sample_rate, num=len(audio)), audio)
plt.grid(True)

import plotly.express as px
px.line (x = t, y = audio )

y=audio
print (y.size)
#ventana = sample_rate // 40
ventana = 256
traslape = 128
# El vector de inicios conserva la información de los valores de las muestras en las que inician las ventanas en que se analiza la señal de voz
inicios = np.arange (0, y.shape[0]-ventana, int(traslape))
# El vector idx lleva la información del número de columna en cuestión
idx = np.arange (0, int(ventana) )
#print (inicios[0: 5])
print (inicios)
print (idx[0: 5])

print (inicios[-5: -1])

# a es el vector columna del vector inicios, esto es se transpone el vector inicios
a = inicios[:, np.newaxis]
#print (a)
# Se crean ventanas conjuntas a lo largo de la señal
idxx = a + idx [np.newaxis:]
print (idxx.shape)

idxx [0:40, 0]

# Se procede a conformar una matriz Y a partir de la señal original
Y = y [idxx]
print (Y.shape)

# El tiempo que corresponde a cada una de las ventanas que se generan
#traslape = int (ventana)
t_ventana = np.arange (0, ventana/sample_rate, 1/sample_rate)

# Se procede a graficar la p-ésima ventana de tiempo
p=1
plt.plot (t_ventana, Y[p,:])
plt.grid()
plt.show()

plt.plot (y[ventana:2*ventana])
plt.grid()
plt.show()

# Se genera una ventana de Hanning, por medio de una matriz de ventanas en función de la cantidad de información de la señal Y
hann = np.hanning(ventana) [np.newaxis,:]
hann = np.tile (hann, (Y.shape[0],1))
print (hann.shape)

plt.plot (t_ventana, hann[0,:])
plt.grid()
plt.show()

# Se procede a multiplicar cada segmento de la señal por la ventana de Hanning
Y_hann = Y * hann

# Se procede a seleccionar la ventana que se desea analizar
i = 18
plt.plot (t_ventana, Y[i,:], label= 'original')
plt.plot (t_ventana, Y_hann[i,:], label = 'hanning')
plt.grid()
plt.legend()
plt.show()

# Se procede a determinar el espectro de cada segmento de la señal original
Yfft = np.fft.fft (Y_hann, axis=1)
#print (Yfft[1:,])

# Se determina o calcula el logaritmo del espectro
YfftdB = 20 * np.log10 (np.abs(Yfft))
print (YfftdB.shape)

# Se grafica es i-ésimo espectro
i=3
plt.plot (YfftdB[i,:])
#plt.plot (YfftdB)
plt.grid()
plt.show()

# Se procede a graficar la mitad del espectro ahora en el dominio de la frecuencia, el eje x es la frecuencia
f = np.arange (0, sample_rate, sample_rate/ventana)
i=3
plt.plot (f,YfftdB[i,:])
plt.xlim (0,sample_rate/2)
plt.grid()
plt.show()

# Se procede a graficar en forma de imagen el espectro
#print (YfftdB[:,100:300].T)
#print (YfftdB.T)
#print (YfftdB.shape)
spectrogram = np.array(YfftdB[:,0:129].T)
print ("hola")
print (traslape)
# Plot the spectrogram
frequencies = np.fft.rfftfreq(ventana, d=1.0/sample_rate)
print (frequencies.shape)
time = np.arange(len(spectrogram[0])) * (ventana - traslape) / sample_rate
print (time.shape)
plt.pcolormesh(time, frequencies, 10 * np.log10(spectrogram))
plt.xlabel("Time (s)")
plt.ylabel("Frequency (Hz)")
plt.colorbar(label="Power spectral density (dB/Hz)")
plt.ylim([0, sample_rate/2.])
plt.show()
# La gráfica muestra los valores invertidos de la frecuencia, con los valores más altos abajo y los inferiores arriba, por lo que se tiene que voltear

from librosa.display import specshow
specshow(YfftdB[:,0:129].T, sr=sample_rate, x_axis='time', y_axis='hz')
plt.xlabel('tiempo [s]')
plt.ylabel('frecuencia [Hz]')
plt.ylim(top=12000)
plt.colorbar()
plt.grid(True)

# Se procede a invertir en forma de imagen el espectro
plt.imshow (YfftdB[:,300:100:-1].T)
#plt.imshow (YfftdB.T)
plt.show()

import seaborn as sbn

sbn.heatmap (YfftdB [:,100:300].T)

spectrogram = YfftdB[:,0:129].T

#spectrogram = YfftdB[:,0:129].T
sbn.heatmap (YfftdB [:,0:129].T)

sbn.heatmap (YfftdB [:,int(sample_rate/2):0:-1].T)

print ('f inicial: ', f[100])
print ('f final:  ',f[200])
